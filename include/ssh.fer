let io = import('std/io');
let fs = import('std/fs');
let os = import('std/os');
let vec = import('std/vec');
let stat = import('std/stat');
let result = import('std/result');
let logging = import('std/logging');

let SSHCon = struct(
    remote = '',
    port = '22',
    user = nil, # optional
    identityFile = nil, # optional
    prefixCounter = 1 # internal variable to manage the `=` count in `=>>` prefix arrows
);
SSHCon.setTypeName('SSHCon');

let new = fn(remote, port, user = nil, identityFile = nil) {
    return SSHCon(remote, port, user, identityFile);
};

let getPrefix in SSHCon = fn() {
    if self.prefixCounter == 1 {
        return '{bm}=>>';
    } elif self.prefixCounter == 2 {
        return '{bm}==>>';
    } elif self.prefixCounter == 3 {
        return '{bm}===>>';
    } elif self.prefixCounter == 4 {
        return '{bm}====>>';
    } elif self.prefixCounter == 5 {
        return '{bm}=====>>';
    }
    return '{bm}' + ('=' * self.prefixCounter) + '>>';
};

let pushDepth in SSHCon = fn() { ++self.prefixCounter; };
let popDepth in SSHCon = fn() { --self.prefixCounter; };

################################ High level helpers ###############################

let tryInstall in SSHCon = fn(.kw, localPath, path) {
    let st = stat.stat(localPath);
    if st.isReg() {
        return self.tryInstallFrom(kw..., localPath, path);
    }
    let items = fs.walkDir(localPath, fs.WALK_RECURSE);
    io.cprintln(self.getPrefix(), ' {by}Installing everything in {bc}', localPath, '{0}!');
    let installed = 0;
    self.pushDepth();
    for item in items.each() {
        if self.tryInstallFrom(kw..., item, path + item.replace(localPath, '')) { ++installed; }
    }
    self.popDepth();
    if installed > 0 {
        io.cprintln(self.getPrefix(), ' {bg}Installed {bc}', installed, '{0}/{bc}', items.len(), '{bg} items in {bc}', path, '{0}!');
        return true;
    }
    io.cprintln(self.getPrefix(), ' {bg}All {bc}', items.len(), ' {bg}items are up to date in {bc}', path, '{0}!');
    return false;
};

let tryInstallFrom in SSHCon = fn(.kw, localPath, path) {
    let data = fs.fopen(localPath).readAll().trim();
    return self.tryInstallData(kw..., path, data);
};

'
Makes sure the file `path` has `data`.
Optionally takes `exclusive = true` which ensures that `data` is the only thing in the file.
'
let tryInstallData in SSHCon = fn(.kw, path, data) {
    let isDataExclusive = kw['exclusive'] ?? false;
    let parentDir = fs.parentDir(path);
    io.cprintln(self.getPrefix(), ' {by}Installing {bc}', path, ' {0}...');
    self.pushDepth();
    let updated = false;
    if !self.tryExists(kw..., path) {
        if !self.tryExists(kw..., parentDir) { self.tryMkdir(kw..., parentDir); }
        self.tryWriteFile(kw..., path, data);
        updated = true;
    } else {
        let existingData = self.tryReadFile(kw..., path).join('\n').trim();
        if (isDataExclusive && data != existingData) || (!isDataExclusive && existingData.find(data) < 0) {
            if isDataExclusive {
                self.tryWriteFile(kw..., path, data);
            } else {
                self.tryWriteFile(kw..., path, existingData + '\n' + data);
            }
            updated = true;
        }
    }
    self.popDepth();
    if updated {
        io.cprintln(self.getPrefix(), ' {bg}Installed {bc}', path, '{0}!');
    } else {
        io.cprintln(self.getPrefix(), ' {bg}Already up to date {bc}', path, '{0}!');
    }
    return updated;
};

################################## Try Wrapppers ##################################

# Helper
let tryBegin in SSHCon = fn(withNewLine, msg...) {
    io.cprint(self.getPrefix(), ' {by}', msg..., ' {0}... ');
    if withNewLine { io.cprintln(); }
};

# Helper
let tryEnd in SSHCon = fn(res, onNewline, msg...) {
    if onNewline && msg != nil {
        io.cprint(self.getPrefix(), ' ');
    }
    if !res.isOk() {
        let failed = 'failed';
        if onNewline { failed = 'Failed'; }
        io.cprintln('{r}', failed, '{0}: {c}', res.getVal().getMsg(), '{0}!');
        feral.exit(res.getVal().getCode());
    }
    if msg != nil && !msg.empty() {
        io.cprint('{bg}');
        for m in msg.each() {
            if m._type_() == FuncTy {
                io.cprint(m(res.getVal()));
            } else {
                io.cprint(m);
            }
        }
        io.cprintln('{0}!');
    } elif !onNewline {
        io.cprintln();
    }
    return ref(res.getVal());
};

let tryConnect in SSHCon = fn(.kw) {
    self.tryBegin(false, 'Connecting to remote');
    let res = self.tryEnd(self.connect(kw...), false, 'success');
    return ref(res);
};

let tryGetEnv in SSHCon = fn(.kw, varName) {
    self.tryBegin(false, 'Getting env var{0}: {bc}', varName);
    let res = self.tryEnd(self.getEnv(kw..., varName), false, 'success');
    return ref(res);
};

let tryCopyFromRemote in SSHCon = fn(.kw, srcPath, destPath) {
    let conStr = self.getConStr();
    return ref(self.tryCopy(kw..., conStr + ':' + srcPath, destPath));
};

let tryCopyToRemote in SSHCon = fn(.kw, srcPath, destPath) {
    let conStr = self.getConStr();
    return ref(self.tryCopy(kw..., srcPath, conStr + ':' + destPath));
};

let tryCopyInRemote in SSHCon = fn(.kw, srcPath, destPath) {
    let conStr = self.getConStr();
    return ref(self.tryCopy(kw..., conStr + ':' + srcPath, conStr + ':' + destPath));
};

let trySymLink in SSHCon = fn(.kw, srcPath, destPath) {
    io.cprintln(self.getPrefix(), ' {by}Symlinking to{0}: {bc}', destPath);
    self.pushDepth();
    if !self.tryExists(destPath) {
        self.tryBegin(false, 'Creating link{0}: {bc}', destPath, ' {by}-> {bc}', srcPath);
        let res = self.tryEnd(self.symLink(kw..., srcPath, destPath), false, 'success');
        self.popDepth();
        return ref(res);
    }
    self.popDepth();
    io.cprintln(self.getPrefix(), ' {bg}Symlink already exists{0}!');
    return result.ok();
};

let tryRemove in SSHCon = fn(.kw, items...) {
    self.tryBegin(false, 'Deleting{0}: {bc}', items.join('{0}, {bc}'));
    let res = self.tryEnd(self.remove(kw..., items...), false, 'success');
    return ref(res);
};

let tryMkdir in SSHCon = fn(.kw, items...) {
    self.tryBegin(false, 'Creating directories{0}: {bc}', items.join('{0}, {bc}'));
    let res = self.tryEnd(self.mkdir(kw..., items...), false, 'success');
    return ref(res);
};

let tryExists in SSHCon = fn(.kw, item) {
    self.tryBegin(false, 'Checking if path exists{0}: {bc}', item);
    let res = self.tryEnd(self.exists(kw..., item), false, fn(val) { return val ? 'yes' : 'no'; });
    return ref(res);
};

let tryReadFile in SSHCon = fn(.kw, path) {
    self.tryBegin(false, 'Reading file{0}: {bc}', path);
    let res = self.tryEnd(self.readFile(kw..., path), false, 'success');
    return ref(res);
};

let tryWriteFile in SSHCon = fn(.kw, path, data) {
    self.tryBegin(false, 'Writing data to file{0}: {bc}', path);
    let res = self.tryEnd(self.writeFile(kw..., path, data), false, 'success');
    return ref(res);
};

let tryAppendFile in SSHCon = fn(.kw, path, data) {
    self.tryBegin(false, 'Appending data to file{0}: {bc}', path);
    let res = self.tryEnd(self.appendFile(kw..., path, data), false, 'success');
    return ref(res);
};

let tryDownload in SSHCon = fn(.kw, url, destPath) {
    self.tryBegin(false, 'Downloading{0}: {bc}', destPath);
    let res = self.tryEnd(self.download(kw..., url, destPath), false, 'success');
    return ref(res);
};

let tryRun in SSHCon = fn(.kw, cmd...) {
    let newLine = true;
    let finishMsg = 'Success';
    if kw['out'] != nil { newLine = false; finishMsg = 'success'; }
    let desc = 'Running command{0}: {bc}' + cmd.join(' ');
    if kw['desc'] != nil { desc = kw['desc']; }
    self.tryBegin(newLine, desc);
    let res = self.tryEnd(self.run(kw..., cmd...), newLine, finishMsg);
    return ref(res);
};

let tryCopy in SSHCon = fn(.kw, src, dest) {
    self.tryBegin(false, 'Copying{0}: {bc}', src, ' {by}-> ', '{bc}', dest);
    let res = self.tryEnd(self.copy(kw..., src, dest), false, 'success');
    return ref(res);
};

################################# Core Functions ##################################

let connect in SSHCon = fn(.kw) {
    let out = '';
    return self.run(kw..., out = out, 'echo', 'test');
};

let getEnv in SSHCon = fn(.kw, varName) {
    let out = '';
    let res = self.run(kw..., out = out, 'echo', '\\$' + varName);
    return res.isOk() ? result.ok(out) : res;
};

let copyFromRemote in SSHCon = fn(.kw, srcPath, destPath) {
    let conStr = self.getConStr();
    return self.copy(kw..., conStr + ':' + srcPath, destPath);
};

let copyToRemote in SSHCon = fn(.kw, srcPath, destPath) {
    let conStr = self.getConStr();
    return self.copy(kw..., srcPath, conStr + ':' + destPath);
};

let copyInRemote in SSHCon = fn(.kw, srcPath, destPath) {
    let conStr = self.getConStr();
    return self.copy(kw..., conStr + ':' + srcPath, conStr + ':' + destPath);
};

let symLink in SSHCon = fn(.kw, srcPath, destPath) {
    let out = '';
    let res = self.run(kw..., out = out, 'ln', '-sf', srcPath, destPath);
    return res.isOk() ? result.ok() : res;
};

let remove in SSHCon = fn(.kw, items...) {
    return self.run(kw..., 'rm', '-rf', items...);
};

let mkdir in SSHCon = fn(.kw, items...) {
    return self.run(kw..., 'mkdir', '-p', items...);
};

let exists in SSHCon = fn(.kw, item) {
    let out = '';
    let res = self.run(kw..., out = out, 'test', '-e', item, '&&', 'echo', 'yes', '||', 'echo', 'no');
    if res.isOk() { return result.ok(out == 'yes' ? true : false); }
    return res;
};

let readFile in SSHCon = fn(.kw, path) {
    let out = vec.new(refs = true);
    let res = self.run(kw..., out = out, 'cat', path);
    return res.isOk() ? result.ok(out) : res;
};

let writeFile in SSHCon = fn(.kw, path, data) {
    let tmpFile = fs.pathFrom(feral.tempPath, 'remoteWrite-' + path.replace('/', '-'));
    io.fprint(fs.fopen(tmpFile, 'w+'), data);
    let res = self.copyToRemote(kw..., tmpFile, path);
    fs.remove(tmpFile);
    return res;
};

let appendFile in SSHCon = fn(.kw, path, data) {
    let tmpFile = fs.pathFrom(feral.tempPath, 'remoteAppend-' + path.replace('/', '-'));
    logging.debug('Appending using temp file: ', tmpFile);
    let res = self.readFile(kw..., path);
    if res.isOk() {
        let f = fs.fopen(tmpFile, 'w+');
        io.fprint(f, res.getVal().join('\n'), '\n', data);
    } else {
        let f = fs.fopen(tmpFile, 'w+');
        io.fprint(f, data);
    }
    let res = self.copyToRemote(kw..., tmpFile, path);
    fs.remove(tmpFile);
    return res;
};

let download in SSHCon = fn(.kw, url, destPath) {
    let out = '';
    return self.run(kw..., out = out, 'curl', '-sL', '-o', destPath, url);
};

let run in SSHCon = fn(.kw, command...) {
    if self.remote.empty() {
        logging.fatal('No remote provided!');
        return result.err(1, 'No remote provided!');
    }
    let output = ref(kw['out']);
    let sudo = kw['sudo'] ?? false;
    let conStr = self.getConStr();
    let cmd = vec.new(refs = true, 'ssh', conStr, '-p', self.port);
    if self.identityFile != nil {
        cmd.push('-i', self.identityFile);
    }
    if sudo { cmd.push('sudo'); }
    cmd.append(command);
    cmd.push('^2>&1');
    logging.debug('Command: ', cmd.join(' '));
    let e = os.exec(cmd, out = output);
    if e != 0 {
        logging.fatal('Command failed!');
        if output != nil {
            return result.err(e, output);
        }
        return result.err(e, 'Command failed');
    }
    logging.debug('Command successful!');
    if output != nil {
        logging.debug('Output: ', output);
    }
    return result.ok();
};

let copy in SSHCon = fn(.kw, src, dest) {
    if self.remote.empty() {
        logging.fatal('No remote provided!');
        return result.err(1, 'No remote provided!');
    }
    let sudo = kw['sudo'] ?? false;
    let skipLen = self.remote.len() + 1; # 1 for colon
    let srcRemote = src.find(self.remote + ':');
    let destRemote = dest.find(self.remote + ':');
    let scpCmd = vec.new(refs = true);
    if srcRemote >= 0 && destRemote >= 0 {
        # just regular (sudo) cp
        return self.run(kw..., out = out, desc = 'Copying within remote', 'cp', '-r', src.sub(srcRemote + 1), dest.sub(destRemote + 1));
    } elif srcRemote >= 0 {
        # (sudo cp from remote src to remote tmp)
        # scp from remote tmp/src to local dest
        let localSrc = src.sub(srcRemote + skipLen);
        let localTmp = '/tmp/' + localSrc.replace('/', '-');
        if sudo {
            let out = '';
            let res = self.run(kw..., out = out, desc = 'Copying to temp file', 'cp', '-r', localSrc, localTmp);
            if !res.isOk() { return ref(res); }
            out = '';
            let res = self.run(kw..., out = out, desc = 'Updating temp file permissions', 'chmod', '-R', '+rx', localTmp);
            if !res.isOk() { return ref(res); }
            localSrc = localTmp;
        }
        let res = self.scp(self.getConStr() + ':' + localSrc, dest);
        if !sudo || !res.isOk() { return res; }
        return self.remove(kw..., localTmp);
    }
    # scp from local src to remote tmp/dest
    # (sudo cp from remote tmp to remote dest)
    let localDest = dest.sub(destRemote + skipLen);
    let tmpDest = localDest;
    if sudo {
        tmpDest = '/tmp/' + tmpDest.replace('/', '-');
    }
    let res = self.scp(src, self.getConStr() + ':' + tmpDest);
    if !sudo || !res.isOk() { return res; }
    let out = '';
    let res = self.run(kw..., out = out, desc = 'Copying from temp file', 'cp', '-r', tmpDest, localDest);
    if !res.isOk() { return res; }
    return self.remove(kw..., tmpDest);
};

let scp in SSHCon = fn(src, dest) {
    let cmd = vec.new(refs = true, 'scp', '-P', self.port);
    if self.identityFile != nil {
        cmd.push('-i', self.identityFile);
    }
    cmd.push('-r', src, dest, '^2>&1');
    logging.debug('Copying: ', cmd.join(' '));
    let output = '';
    let e = os.exec(cmd, out = output);
    if e != 0 {
        logging.fatal('Copying failed!');
        return result.err(e, 'Copying failed: ', output);
    }
    logging.debug('Copying successful!');
    return result.ok();
};

let getConStr in SSHCon = fn() {
    let conStr = '';
    if self.user != nil {
        conStr += self.user + '@';
    }
    conStr += self.remote;
    return conStr;
};

let str in SSHCon = fn() {
    return self.getConStr();
};